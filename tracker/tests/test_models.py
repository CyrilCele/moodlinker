"""
Unit tests for tracker models: User, Address, UserProfile, Notification,
Habit, HabitReminder, MoodEntry, and HabitCompletion.

Each test targets a small, specific behavior:
    - auto-generation of user calendar_token
    - __str__ implementations
    - timezone resolution for UserProfile
    - uniqueness constraints and ordering
    - helper methods (like Habit.user_habits_limit)
"""

import pytest
from django.utils import timezone
from django.db import IntegrityError

from tracker.models import (
    User,
    Address,
    UserProfile,
    Notification,
    Habit,
    HabitReminder,
    MoodEntry,
    HabitCompletion,
)


@pytest.mark.django_db
def test_user_token_autogenerated():
    """
    Ensure a calendar_token is generated automatically for new users and
    has the expected length (hex string of 64 characters produced by secrets.token_hex(32)).
    """
    user = User.objects.create_user(username="testuser", password="pass123")

    # Token should be a non-empty string of 64 hex characters
    assert user.calendar_token is not None, "calendar_token should be autogenerated"
    assert isinstance(user.calendar_token,
                      str), "calendar_token must be a string"
    assert len(
        user.calendar_token) == 64, "calendar_token should be 64 characters (32 bytes hex)"


@pytest.mark.django_db
def test_address_str():
    """
    Verify the __str__ representation of Address returns a readable single-line address.
    """
    address = Address.objects.create(
        street_address="123 Main St",
        city="Cape Town",
        country="South Africa",
        postal_code="8001"
    )

    assert str(
        address) == "123 Main St, Cape Town, South Africa", "Address.__str__ output mismatch"


@pytest.mark.django_db
def test_userprofile_timezone_resolution():
    """
    Verify UserProfile.tz() returns a ZoneInfo for valid timezone settings and
    falls back to UTC for invalid values.
    """
    user = User.objects.create_user(username="tester", password="pass123")

    # Ensure there isn't an existing profile from signals - create one explicitly
    UserProfile.objects.filter(user=user).delete()
    profile = UserProfile.objects.create(
        user=user, timezone="Africa/Johannesburg"
    )

    tz = profile.tz()
    # ZoneInfo exposes the key (name) which should match the configured tomezone
    assert getattr(
        tz, "key", None) == "Africa/Johannesburg", "Profile tz() did not return expected zone"

    # Set an invalid timezone; tz() should return UTC as fallback
    profile.timezone = "Not_A_Zone"
    profile.save()
    assert getattr(profile.tz(), "key",
                   None) == "UTC", "Invalid timezone must fallback to UTC"


@pytest.mark.django_db
def test_userprofile_str():
    """
    UserProfile.__str__ should include the related user's username
    """
    user = User.objects.create_user(username="notifyuser", password="pass123")
    profile, _ = UserProfile.objects.get_or_create(user=user)

    assert str(
        profile) == f"{user.username}'s Profile.", "UserProfile.__str__ format changed"


@pytest.mark.django_db
def test_notification_creation_and_ordering():
    """
    Notifications should be ordered newest-first (Meta.ordering = ["-created_at"]).
    Also check Notification.__str__ contains the "Notification(" prefix for readability.
    """
    user = User.objects.create_user(username="notifyuser", password="pass123")

    Notification.objects.create(user=user, message="First")
    Notification.objects.create(user=user, message="Second")

    # Query respects model ordering (newest first)
    notifications = list(Notification.objects.filter(user=user))

    # The most recently created notification should be first
    assert notifications, "Expected at least one notification"
    assert notifications[0].message == "Second", "Notifications ordering should be newest-first"
    assert "Notification(" in str(
        notifications[0]), "Notification.__str__ should include class name"


@pytest.mark.django_db
def test_habit_creation_and_str():
    """
    Habit.__str__ should include the habit name and the user's username
    """
    user = User.objects.create_user(username="habituser", password="pass123")
    habit = Habit.objects.create(
        user=user, habit="Meditate", periodicity="daily", description="Test habit"
    )

    assert str(
        habit) == f"Habit: Meditate for {user.username}", "Habit.__str__ format mismatch"


@pytest.mark.django_db
def test_habit_uniqueness_constraint():
    """
    Creating two Habit records with the same (user, habit) should raise an IntegrityError
    because of the UniqueConstraint defined on the model.
    """
    user = User.objects.create_user(username="habitdup", password="pass123")
    Habit.objects.create(user=user, habit="Read", periodicity="daily")

    # Attempting to create a duplicate habit for the same user must raise an IntegrityError
    with pytest.raises(IntegrityError):
        Habit.objects.create(user=user, habit="Read", periodicity="daily")


@pytest.mark.django_db
def test_habit_user_habits_limit():
    """
    Habit.user_habits_limit(user) returns False once a user has 5 or more habits.
    """
    user = User.objects.create_user(username="habitlimit", password="pass123")

    # Seed exactly 5 habits
    for i in range(5):
        Habit.objects.create(user=user, habit=f"Habit{i}", periodicity="daily")

    assert Habit.user_habits_limit(
        user) is False, "user_habits_limit should return False at the limit"


@pytest.mark.django_db
def test_habitreminder_uniqueness_and_str():
    """
    HabitReminder should have a unique_together constraint (user, habit) and a readable __str__.
    """
    user = User.objects.create_user(
        username="reminderuser", password="pass123"
    )
    habit = Habit.objects.create(user=user, habit="Jog", periodicity="daily")
    now = timezone.now()

    reminder = HabitReminder.objects.create(
        user=user, habit=habit, next_trigger_utc=now
    )

    # __str__ should show username and habit name at minimum
    assert str(reminder).startswith(
        f"Reminder({user.username}, {habit.habit})"), "HabitReminder.__str__ format unexpected"

    # Creating a second reminder for the same user & habit should violate unique constraint
    with pytest.raises(IntegrityError):
        HabitReminder.objects.create(
            user=user, habit=habit, next_trigger_utc=now
        )


@pytest.mark.django_db
def test_moodentry_creation_and_uniqueness():
    """
    MoodEntry should stringify usefully and enforce unique_together (user, date).
    Creating a duplicate entry for the same user and day should raise IntegrityError.
    """
    user = User.objects.create_user(username="mooduser", password="pass123")
    entry = MoodEntry.objects.create(
        user=user, score=3, reflection="Feeling ok"
    )

    assert str(entry).startswith(
        f"{user.username} - Mood: {entry.score}"), "MoodEntry.__str__ unexpected"

    # Second create (same user, implicitly same date) should raise IntegrityError
    with pytest.raises(IntegrityError):
        MoodEntry.objects.create(user=user, score=4, reflection="Duplicate")


@pytest.mark.django_db
def test_habitcompletion_uniqueness_and_str():
    """
    HabitCompletion enforces unique_together (user, habit, date); also verify stringification and boolean field.
    """
    user = User.objects.create_user(username="compuser", password="pass123")
    habit = Habit.objects.create(
        user=user, habit="Stretch", periodicity="daily"
    )

    # Create a completion (date defaults to auto_now_add)
    completion = HabitCompletion.objects.create(
        user=user, habit=habit, completed=True
    )

    assert completion.completed is True, "Completed flag should be True as created"

    # Creating a second completion for the same (user, habit, date) must raise IntegrityError
    with pytest.raises(IntegrityError):
        HabitCompletion.objects.create(user=user, habit=habit, completed=False)
